syntax = "proto3";

import "google/protobuf/duration.proto";

option go_package = "github.com/nyiyui/qrystal/node/api";

message Ok {
}

service Node {
  rpc auth(stream AuthSQ) returns (stream AuthSQ);
  // #  client - server
  // 1. AuthQ  →
  // 2.        ← AuthS
  // 3.        ← AuthQ
  // 4. AuthS  →

  rpc xch(XchQ) returns (XchS);

  rpc ping(PingQS) returns (PingQS);
}

service CentralSource {
  rpc pull(PullQ) returns (stream PullS);
  rpc push(PushQ) returns (PushS);
  rpc addToken(AddTokenQ) returns (AddTokenS);
  rpc canForward(CanForwardQ) returns (CanForwardS);

  rpc ping(PingQS) returns (PingQS);
}

service Kiriyama {
  rpc getStatus(GetStatusQ) returns (stream GetStatusS);
}

message AuthSQ {
  oneof sq {
    AuthS s = 1;
    AuthQ q = 2;
    AuthToken token = 3;
  }
}

message AuthQ {
  string network = 1;
  string me = 2;
  string you = 4;
  bytes chall = 5;
}

message AuthS {
  bytes challResp = 1;
  bytes challAdded = 2;
}

message AuthToken {
  bytes token = 1;
}

message XchQ {
  bytes token = 1;
  bytes pubKey = 2;
  bytes psk = 3;
}

message XchS {
  bytes pubKey = 1;
}

message PingQS {}

message PullQ {
  string centralToken = 1;
}

message PullS {
  CentralConfig cc = 1;
  ForwardPreQ fc = 2;
  bool forwardingOnly = 3;
  repeated string changedCNs = 5; // TODO: stop these bodges (:
  string reason = 4;
  //TODO: eventually migrate to oneof
}

message PushQ {
  string centralToken = 1;
  string cnn = 2;
  string peerName = 3;
  CentralPeer peer = 4;
  // peer to add. If CentralPeer.allowedIPs is blank, 1 IP address (which is not already used) is assigned automatically.
}

message PushS {
  oneof s {
    Ok ok = 1;
    string invalidData = 2;
    string overflow = 3;
    string other = 4;
  }
}

message CentralConfig {
  map<string, CentralNetwork> networks = 1;
}

message CentralNetwork {
  repeated IPNet ips = 1;
  string me = 2;
  google.protobuf.Duration keepalive = 3;
  int32 listenPort = 4;
  map<string, CentralPeer> peers = 5;
}

message CentralPeer {
  string host = 1;
  repeated IPNet allowedIPs = 2;
  repeated string forwardingPeers = 4;
  // forwardingPeers lists the allowedIPs this peer can forward for.
  // forwardingPeers may overlap (i.e. duplicate IPs may appear in other
  // CentralPeers), so nodes must choose one for their WireGuard config.
  PublicKey publicKey = 3;
}

message PublicKey {
  bytes raw = 1;
}

message IPNet {
  string cidr = 1;
}

message AddTokenQ {
  string centralToken = 1;
  bool overwrite = 2;
  bytes hash = 3;
  string name = 4;
  map<string, string> networks = 5;
  bool canPull = 6;
  CanPush canPush = 7;
}

message CanPush {
  map<string, string> networks = 1;
}

message AddTokenS {}

message ForwardPreQ {
  string network = 1;
  string forwardee_peer = 2;
}

message CanForwardQ {
  string centralToken = 1;
  string network = 2;
  repeated string forwardeePeers = 3;
  ForwardMetric metric = 4;
}

message ForwardMetric {
  uint64 latency = 1;
  // latency in nanoseconds
  double bandwidth = 2;
  // bandwidth in bps
}

message CanForwardS {}

message GetStatusQ {}

message GetStatusS {
  map<int32, CSStatus> cs = 1;
  map<string, string> peer = 2;
}

message CSStatus {
  string name = 1;
  string status = 2;
}
